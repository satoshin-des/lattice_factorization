

# This file was *autogenerated* from the file sato_fact.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2p2 = RealNumber('2.2'); _sage_const_8 = Integer(8); _sage_const_15 = Integer(15); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_0p5 = RealNumber('0.5'); _sage_const_100000 = Integer(100000); _sage_const_0 = Integer(0); _sage_const_20 = Integer(20)
from fpylll import *
from time import perf_counter
from random import shuffle
import numpy as np

N: ZZ = ZZ(input("N = "))

start = perf_counter()

f: bool = False
R = Integers(N)
bit_size: int = N.nbits()
n: int = round(_sage_const_2p2  * bit_size / log(bit_size) - _sage_const_8 )
n = _sage_const_15 
m: int = n + _sage_const_1 
K: int = _sage_const_2  * n * n; J = K * _sage_const_0p5 

P = np.array([-_sage_const_1 ])
for i in range(K):
    P = np.append(P, next_prime(P[i]))

B_right = np.array([np.ceil(_sage_const_100000  * np.log2(P[_sage_const_1  : n + _sage_const_1 ]))]).T

S = np.arange(_sage_const_1 , m); S = np.ceil(S * _sage_const_0p5 )

#Construction of a target vector
t = vector(ZZ, m); t[n] = ceil(_sage_const_100000  * log(N, _sage_const_2 ));

List = []; r: int = _sage_const_0 ; num: int = _sage_const_0 ; already_set: list = []; loop_times: ZZ = _sage_const_0 
while True:
	nseach: int = _sage_const_0 
	loop_times += _sage_const_1 
	# Construction of lattice basis
	shuffle(S)
	C = Matrix(ZZ, np.hstack([np.diag(S), B_right]))
	B = IntegerMatrix.from_matrix(C)

	# Lattice basis reduction
	LLL.reduction(B)
	M = GSO.Mat(B)
	_ = M.update_gso()
	
	# Babai's algorithm 
	w = M.babai(t); cv = B.multiply_left(w);

	# Solving approximate CVP
	radius: RR = (vector(ZZ, cv) - t).norm() ** _sage_const_2 
	solutions = []
	enum = Enumeration(M, strategy = EvaluatorStrategy.BEST_N_SOLUTIONS, nr_solutions = _sage_const_20 )
	solutions = enum.enumerate(_sage_const_0 , n, radius, _sage_const_0 , M.from_canonical(t))
	
	for a, b in solutions:
		b = IntegerMatrix.from_iterable(_sage_const_1 , B.nrows, map(lambda x: int(round(x)), b)); w = b * B
		e = C.solve_left(vector(ZZ, w[_sage_const_0 ]))
		
		# Construction of (u, v)-pairs
		u: ZZ = _sage_const_1 ; v: ZZ = _sage_const_1 
		for j in range(n):
			if e[j] > _sage_const_0 : u *= P[j + _sage_const_1 ] ** e[j]
			elif e[j] < _sage_const_0 : v *= P[j + _sage_const_1 ] ** (-e[j])
		
		# Smoothness check
		T: ZZ = u - v * N
		F = factor(T)
		L = list(F)
		if len(set(L[:][_sage_const_0 ]) - set(P)) == _sage_const_0 :
			vec = vector(ZZ, n)
			for j in range(n):
				p: int = P[j + _sage_const_1 ]
				e1: ZZ = _sage_const_0 ; e2: ZZ = _sage_const_0 
				U: ZZ = u
				while True:
					if mod(U, p) == _sage_const_0 :
						e1 += _sage_const_1 ; U /= p
					else:
						break

				while True:
					if mod(T, p) == _sage_const_0 :
						e2 += _sage_const_1 ; T /= p
					else:
						break
				vec[j] = e2 - e1
			if vec not in List:
				num += _sage_const_1 
				print(num, "sr-pairs are found. (K =", K, ")")
				List.append(vec);
				AA = Matrix(GF(_sage_const_2 ), List)
				r = AA.rank()

	if num >= K:
		if len(List) > r:
			V = AA.kernel();
			for tt in V:
				if tt not in already_set:
					already_set.append(tt)
					if not tt.is_zero():
						ee = vector(ZZ, n) 
						for j in range(len(tt)):
							if tt[j] == _sage_const_1 :
								ee += List[j]
						X = R(_sage_const_1 ); Y = R(_sage_const_1 )
						for j in range(n):
							if ee[j] > _sage_const_0 :
								X *= R(P[j + _sage_const_1 ]) ** ZZ(ee[j] * _sage_const_0p5 )
							elif ee[j] < _sage_const_0 :
								Y *= R(P[j + _sage_const_1 ]) ** ZZ(-ee[j] * _sage_const_0p5 )
						print("X =", X, ", Y =", Y)
						if X != Y:
							p: ZZ = gcd(ZZ(X - Y), N)
						else:
							p: ZZ = gcd(ZZ(X + Y), N)
						if _sage_const_1  < p < N:
							print("==============================\nN = ", N, ", bit size = ", N.nbits(), "\nc = 5, beta = 2.0\nN = ", p, " * ", N / p, "\nloop times = ", loop_times, "\nnumber of sr-pairs = ", num, "\n==============================")
							f = True; break
					if f:
						break
			if f:
				break

end = perf_counter()
print(end - start, "[secs]")

